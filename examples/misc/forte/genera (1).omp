; OM File Header - Saved 2021/07/09 21:52:18
; (6.2 :patc (om-make-point 104 13) (om-make-point 0 0) (om-make-point 960 568) "No documentation " 183 0 nil "2021/07/09 21:52:18")
; End File Header
; External resources 
; (list (list (quote :abstraction) "#P\"basics/from_forte_numbers.omp\""))
(in-package :om)(load-lib-for (quote ("OMPitchField")))(setf *om-current-persistent* (om-load-patch1 "genera (1)" (quote ((let ((box (om-load-boxcall (quote genfun) "P->MC" (quote p->mc) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" nil))) (om-make-point 727 404) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "objs" "SELF" nil) (om-load-inputfun (quote input-funbox) "no documentation" "LMIDIC" (list 6000)) (om-load-inputfun (quote input-funbox) "no documentation" "LONSET" (list 0 1000)) (om-load-inputfun (quote input-funbox) "no documentation" "LDUR" (list 1000)) (om-load-inputfun (quote input-funbox) "no documentation" "LVEL" (list 100)) (om-load-inputfun (quote input-funbox) "no documentation" "LOFFSET" (list 0)) (om-load-inputfun (quote input-funbox) "no documentation" "LCHAN" (list 1)) (om-load-inputfun (quote input-funbox) "no documentation" "LEGATO" 0))) (om-make-point 720 456) (om-make-point 148 106) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6000 6100 6200 6600) (6000 6100 6200 6700) (6000 6100 6500 6600) (6000 6100 6600 6700) (6000 6100 6300 6600) (6000 6100 6400 6600) (6000 6100 6500 6700) (6000 6100 6400 6700) (6000 6100 6300 6700) (6000 6100 6200 6300 6400) (6000 6100 6200 6300 6500) (6000 6100 6200 6400 6500) (6000 6200 6300 6400 6600) (6000 6200 6300 6400 6700) (6000 6100 6300 6400 6800) (6000 6100 6400 6500 6800) (6000 6200 6300 6500 6700) (6000 6200 6400 6500 6800) (6000 6100 6300 6500 6800) (6000 6200 6400 6600 6800) (6000 6200 6400 6600 6900) (6000 6200 6400 6700 6900) (6000 6300 6400 6500 6800) (6000 6100 6200 6300 6600 6700) (6000 6100 6200 6500 6600 6700) (6000 6100 6200 6600 6700 6800) (6000 6100 6200 6400 6600 6700) (6000 6100 6300 6400 6600 6700) (6000 6100 6200 6400 6700 6800) (6000 6100 6200 6500 6700 6800) (6000 6200 6300 6500 6600 6800) (6000 6100 6300 6400 6600 6900) (6000 6200 6300 6600 6700 6900) (6000 6100 6300 6600 6700 6900) (6000 6100 6200 6300 6700 6800) (6000 6100 6200 6300 6600 6800) (6000 6100 6200 6300 6600 6900) (6000 6100 6200 6500 6600 6800) (6000 6100 6300 6400 6700 6900) (6000 6100 6400 6600 6700 6900))) :lonset (quote (0 500 1000 1500 2000 2500 3000 3500 4000 5000 5500 6000 6500 7000 7500 8000 8500 9000 9500 10000 10500 11000 11500 12500 13000 13500 14000 14500 15000 15500 16000 16500 17000 17500 18000 18500 19000 19500 20000 20500 21500)) :ldur (quote ((1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000) (1000 1000 1000 1000 1000 1000))) :lvel (quote ((100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100) (100 100 100 100 100 100))) :loffset (quote ((0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0))) :lchan (quote ((1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1) (1 1 1 1 1 1))) :legato 0)))) (load-port-info newobj (quote ((0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0) (0 0 0 0 0 0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale microplay winpos winsize mode grillestep notechancolor? zoom inport outport deltapict cmnpref staff fontsize approx palette-mode obj-mode show-stems)) (list nil nil 2621450 18350450 0 1000 nil 1 0 0 (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2 0 0 (quote t))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NESTING->TIMING" (quote nesting->timing) (quote ((om-load-inputfun (quote input-funbox) "nested list of numbers" "LST" nil) (om-load-inputfun (quote input-funbox) "number of nested levels to flatten [or if negative, abs val is number of nested levels to remain after flattening]" "LEVELS" -1) (om-load-inputfun (quote input-funbox) "time unit separating members of same sublist (multiplied at sublist boundaries)" "TIME-UNIT" 500))) (om-make-point 728 340) nil nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST2" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 545 427) (om-make-point 63 37) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment1" (om-make-point 193 90) (quote "GENUS (nickname) PROGENITOR$1 (atonal) 3-5$2 (whole-tone) 3-8$3 (diminished) 3-10$4 (augmented) 3-12") "" (om-make-point 699 134) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:bold)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 715 96) (quote "Forte's \"genera\" are twelve families of pcset classes based on special inclusion relations. Certain pairs of interval classes occur in one and only one trichordal set class, and each of these set classes acts by itself as \"progenitor\" of one of Forte's genera. There are three such set classes.$$Furthermore, the \"augmented triad\" set class, 3-12, is the only trichord to contain only (three instances of) a single interval class. It too plays the role of progenitor. To produce a listing of the tetrachords, pentads, and hexachords of Forte's single-progenitor genera, enter the appropriate progenitor from the following table:") "" (om-make-point 184 4) nil (om-make-color 0 0 0) (om-make-font "Geneva" 10 :family "Geneva" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch11" (om-load-patch-abs1 "contain" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 184 329) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ZEROP" (quote zerop) (quote ((om-load-inputfun (quote input-funbox) "NUMBER" "NUMBER" nil))) (om-make-point 145 284) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 160 45) "no documentation" "classreps" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPLY" (quote apply) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" (quote +)) (om-load-inputfun (quote input-funbox) "FIRST-ARG" "FIRST-ARG" nil))) (om-make-point 133 220) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 110 45) "no documentation" "chord" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "INCL-VEC" (quote incl-vec) (quote ((om-load-inputfun (quote input-funbox) "list of integers" "CHORD" nil) (om-load-inputfun (quote input-funbox) "list of items, each an integer or an integer list beginning :t, :ti, :tp, or :tip" "CLASSREPS" (list 1 2 3 4 5 6)))) (om-make-point 122 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (5 0 3 1 nil 0) (4 0 5 0 nil 0) (2 0 5 1 nil 0))) 6.2 nil "" (om-make-point 0 0) (om-make-point 400 472)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "chord" nil) (om-load-inputfun (quote input-funbox) "no documentation" "classreps" nil))) (om-make-point 545 252) nil (list nil) "l" "contain"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FILTER-CHORDLIST21" (quote filter-chordlist) (quote ((om-load-inputfun (quote input-funbox) "test" "TEST" nil) (om-load-inputfun (quote input-funbox) "list of chords" "CHORDLIST" nil) (om-load-inputfunmenu1 (quote input-funmenu) "" "REJECT" (quote t) (list (list "pass" nil) (list "reject" (quote t)))))) (om-make-point 558 331) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list411" (quote list) (quote nil) (om-make-point 612 177) (om-make-point 20 28) 6 "6" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-TI-PRIMEFORMS11" (quote list-ti-primeforms) (quote ((om-load-inputfun (quote input-funbox) "number of elements in each primeform (or a list of such numbers)" "CARD" 3))) (om-make-point 598 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch2" (om-load-patch-abs1 "ti-tags" (quote ((let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "X" "X" (quote :ti)) (om-load-inputfun (quote input-funbox) "LIST-OR-THING" "LIST-OR-THING" nil))) (om-make-point 183 160) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 199 82) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 194 223) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 1 nil 0) (0 0 2 0 nil 0))) 6.2 nil "" (om-make-point 0 0) (om-make-point 400 472)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 274 424) nil (list nil) "l" "ti-tags"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR1" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 349 440) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FILTER-CHORDLIST2" (quote filter-chordlist) (quote ((om-load-inputfun (quote input-funbox) "test" "TEST" nil) (om-load-inputfun (quote input-funbox) "list of chords" "CHORDLIST" nil) (om-load-inputfunmenu1 (quote input-funmenu) "" "REJECT" (quote t) (list (list "pass" nil) (list "reject" (quote t)))))) (om-make-point 329 331) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch1" (om-load-patch-abs1 "contain" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 184 329) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "ZEROP" (quote zerop) (quote ((om-load-inputfun (quote input-funbox) "NUMBER" "NUMBER" nil))) (om-make-point 145 284) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 160 45) "no documentation" "classreps" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "APPLY" (quote apply) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" (quote +)) (om-load-inputfun (quote input-funbox) "FIRST-ARG" "FIRST-ARG" nil))) (om-make-point 133 220) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 110 45) "no documentation" "chord" nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "INCL-VEC" (quote incl-vec) (quote ((om-load-inputfun (quote input-funbox) "list of integers" "CHORD" nil) (om-load-inputfun (quote input-funbox) "list of items, each an integer or an integer list beginning :t, :ti, :tp, or :tip" "CLASSREPS" (list 1 2 3 4 5 6)))) (om-make-point 122 114) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (3 0 1 0 nil 0) (5 0 3 1 nil 0) (4 0 5 0 nil 0) (2 0 5 1 nil 0))) 6.2 nil "" (om-make-point 0 0) (om-make-point 400 444)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "chord" nil) (om-load-inputfun (quote input-funbox) "no documentation" "classreps" nil))) (om-make-point 306 252) nil (list nil) "l" "contain"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list41" (quote list) (quote nil) (om-make-point 377 182) (om-make-point 20 28) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-TI-PRIMEFORMS1" (quote list-ti-primeforms) (quote ((om-load-inputfun (quote input-funbox) "number of elements in each primeform (or a list of such numbers)" "CARD" 3))) (om-make-point 359 210) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "mypatch" (om-load-patch-abs1 "ti-tags" (quote ((let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "X" "X" (quote :ti)) (om-load-inputfun (quote input-funbox) "LIST-OR-THING" "LIST-OR-THING" nil))) (om-make-point 183 160) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 199 82) "no documentation" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 194 223) (quote ((om-load-inputfun (quote input-funbox) "out" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 1 nil 0) (0 0 2 0 nil 0))) 6.2 nil "" (om-make-point 0 0) (om-make-point 400 472)) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "input" nil))) (om-make-point 45 435) nil (list nil) "l" "ti-tags"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 120 461) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST31" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil))) (om-make-point 86 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MAKE-INCLUSION-TEST" (quote make-inclusion-test) (quote ((om-load-inputfun (quote input-funbox) "list of triples: FIRST integer in [1 , 6] or integer list beginning :t, :ti, :tp, or :tip; SECOND & THIRD integers" "INCSPEC-TRIPLES" (list (list (list (quote :t) 0 1 2) 0 1))))) (om-make-point 5 277) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FILTER-CHORDLIST" (quote filter-chordlist) (quote ((om-load-inputfun (quote input-funbox) "test" "TEST" nil) (om-load-inputfun (quote input-funbox) "list of chords" "CHORDLIST" nil) (om-load-inputfunmenu1 (quote input-funmenu) "" "REJECT" nil (list (list "pass" nil) (list "reject" (quote t)))))) (om-make-point 100 352) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list4" (quote list) (quote nil) (om-make-point 135 199) (om-make-point 20 28) 4 "4" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "LIST-TI-PRIMEFORMS" (quote list-ti-primeforms) (quote ((om-load-inputfun (quote input-funbox) "number of elements in each primeform (or a list of such numbers)" "CARD" 3))) (om-make-point 117 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LIST3" (quote list) (quote ((om-load-inputfun (quote input-funbox) "add-input" "add-input" nil) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 1) (om-load-inputfun (quote input-funbox) "add-input" "add-input" 99))) (om-make-point 13 177) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "X" "X" (quote :ti)) (om-load-inputfun (quote input-funbox) "LIST-OR-THING" "LIST-OR-THING" nil))) (om-make-point 51 136) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list1" (quote list) (quote nil) (om-make-point 104 35) (om-make-point 20 28) 5 "5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 46 35) (om-make-point 20 28) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote patch-box) "from_forte_numbers" (quote ("elements" "OMPitchField-tutorial-patches" "misc" "forte" "basics" "from_forte_numbers")) (quote ((om-load-inputfun (quote input-funbox) "no documentation" "card" nil) (om-load-inputfun (quote input-funbox) "no documentation" "forte-num" nil))) (om-make-point 28 66) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (0 0 1 1 nil 0) (2 1 1 2 nil 0) (3 0 2 0 nil 0) (20 0 3 0 nil 1) (12 0 3 1 nil 5) (7 0 3 2 nil 6) (11 0 6 1 nil 0) (6 0 7 0 nil 0) (9 0 7 1 nil 0) (8 0 9 0 nil 0) (10 0 11 0 nil 0) (12 0 11 1 nil 5) (13 0 12 0 nil 0) (15 0 12 1 nil 0) (17 0 13 1 nil 0) (14 0 15 0 nil 0) (16 0 17 0 nil 0) (20 0 17 1 nil 1) (23 0 18 0 nil 0) (18 0 19 0 nil 0) (19 0 20 0 nil 0) (22 0 20 1 nil 0) (21 0 22 0 nil 0) (24 0 23 0 nil 0) (27 0 24 1 nil 0) (26 0 27 0 nil 0) (25 0 27 1 nil 0))) nil 6.2))
